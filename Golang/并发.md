## go语言并发组件

### goroutine

	• 每个go语言程序都至少有一个goroutine：main goroutine，它在进程开始时自动创建并启动  
	• goroutine会在它们所创建的相同地址空间内执行  
	• 所有的gotoutine都不运行则死锁

### sync包

	• 包含对低级别内存访问同步最有用的并发原语

#### waitgroup

	• 并发安全的计数器：通过调用传入的整数执行add方法来增加计数器的增量，并调用Done方法对计数器进行递减。Wait阻塞，直到计数器为0

#### 互斥锁和读写锁

	• Mutex互斥锁，包含Lock和Unlock方法  
		○ 在defer语句中调用Unlock，是一个惯用法，它使用Mutex互斥锁来确保即使出现了panic，调用也总是发生。如果不这样做，可能会导致程序陷入死锁  
	• RWMutex读写锁  
		○ 在概念上和互斥是一样的，然而RWMutex让你对内存有了更多的控制。你可以请求一个锁用于读处理，在这种情况下你将被授予访问权限，除非该锁被用于写处理。这意味着任意数量的读消费者可以持有一个读锁，只要没有其它事物持有写锁。  
	• 通常建议使用RWMutex

#### cond

	• sync.Cond用于goroutine之间的协作，用于协程的挂起和唤醒  
	• 比较冷门

#### once

	• sync.Once是一种类型，它在内部使用一些sync原语，以确保即使在不同的goroutine上，也只会调用一次Do方法处理传递进来的函数  
	• snyc.Once只计算调用Do方法的次数，而不是多少次唯一调用Do方法

#### Pool

	• 这是go中实现的一个对象池，为什么要有这个池呢？首先go是自带垃圾回收机制（也就是通常所说的gc）。gc会带来运行时的开销，对于高频的内存申请与释放，如果将不用的对象存放在一个池子中，用的时候从池子中取出一个对象，用完了再还回去，这样就能减轻gc的压力  
	• 对于池这个概念，之前可能听说过连接池。能否用sync.Pool实现一个连接池呢？答案是不能的。因为对于sync.Pool而言，我们无法保证每次放回去再取出来的对象是与之前一致的，对象的内存存在着呗销毁的可能。因此，这个sync.Pool的存在仅仅是为了减缓gc的压力而生的。  
	• 特点  
		○ sync.Pool是一个存储临时对象的对象池  
		○ 任何存储在sync.Pool中的变量随时都有可能被销毁，并且销毁的同时没有任何通知  
		○ pool中的对象数量是不可控的  
		○ 当pool中只有一个对象时，这块内存有可能被回收  
		○ sync.Pool是协程安全的  
	• 当实例化sync.Pool时，使用new方法创建一个成员变量，在调用时是线程安全的  
	• 当收到一个来自Get的实例时，不要对所接收的对象的状态作出任何假设  
	• 当用完了一个从Pool中取出的对象时，一定要调用Put，否则，Pool就无法复用这个实例了，通常使用defer来实现  
	• Pool内的分布必须大致均匀

## sync.Map
